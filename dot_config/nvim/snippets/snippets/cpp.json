{
    "Arc Structure": {
        "prefix": "_arc",
        "body": [
            "struct Arc {\\\n    int v, cost;\\\n    Arc() {}\\\n    Arc(int d, int peso) { v = d; cost = peso; }\\\n    bool operator < (const Arc &a) const { return cost > a.cost; }\\\n};"
        ],
        "description": "This structure represents an Arc with a value 'v' and a cost 'cost'. It includes a constructor to initialize the values and an overloaded '<' operator to compare the cost of two Arc objects."
    },
    "Graph Structure": {
        "prefix": "_graph",
        "body": [
            "typedef struct {\\\n    int n;\\\n    vector<int> ady[aa];\\\n} Grafo;"
        ],
        "description": "This is a structure that represents a graph. It contains an integer 'n' and an array of vectors 'ady' which stores adjacency lists for the graph. The size of the array is defined by 'aa'."
    },
    "AVL Tree Structure": {
        "prefix": "_avltree",
        "body": [
            "struct AVLTree {\\\n    int data;\\\n    AVLTree *left;\\\n    AVLTree *right;\\\n    int height;\\\n};"
        ],
        "description": "This structure represents an AVL Tree node. It contains an integer 'data' for the node's value, pointers 'left' and 'right' to the left and right child nodes, and an integer 'height' to store the height of the node."
    },
    "File Redirection for Environment Setup": {
        "prefix": "_in",
        "body": [
            "#ifdef my_env\\\n    freopen(\"/home/daniel/input\", \"r\", stdin);\\\n    //freopen(\"/tmp/out\", \"w\", stdout);\\\n#endif"
        ],
        "description": "This block of code redirects input from a specific file when the 'my_env' macro is defined. It opens '/home/daniel/input' as the input stream. The output redirection is commented out but can be enabled if needed."
    },
   "biguint Class": {
        "prefix": "_biguint",
        "body": [
            "namespace arith {",
            "    typedef unsigned int uint;",
            "    typedef unsigned long long ull;",
            "    const int LOGBASE = sizeof (uint)*8;",
            "    const ull BASE = 1ULL << LOGBASE;",
            "",
            "    inline void assert_msg(bool cond, const std::string& msg) {",
            "        if (!cond) {",
            "            std::cerr << \"arith: \" << msg << std::endl;",
            "            exit(1);",
            "        }",
            "    }",
            "",
            "    inline void strip(std::vector<uint>& r, int pos = 0) {",
            "        while (r.size() > pos && !r.back()) r.pop_back();",
            "    }",
            "",
            "    inline void add(const std::vector<uint>& x, ull s, std::vector<uint>& r) {",
            "        r.resize(x.size());",
            "        for (int i = 0; i < x.size(); ++i) {",
            "            s += x[i];",
            "            r[i] = s;",
            "            s >>= LOGBASE;",
            "        }",
            "        if (s) r.push_back(s);",
            "    }",
            "",
            "    inline void add(const std::vector<uint>& x, const std::vector<uint>& y, std::vector<uint>& r) {",
            "        r.resize(std::max(x.size(), y.size()));",
            "        ull s = 0;",
            "        int i = 0;",
            "        for (; i < x.size() && i < y.size(); ++i) {",
            "            s += x[i];",
            "            s += y[i];",
            "            r[i] = s;",
            "            s >>= LOGBASE;",
            "        }",
            "        for (; i < x.size(); ++i) {",
            "            s += x[i];",
            "            r[i] = s;",
            "            s >>= LOGBASE;",
            "        }",
            "        for (; i < y.size(); ++i) {",
            "            s += y[i];",
            "            r[i] = s;",
            "            s >>= LOGBASE;",
            "        }",
            "        if (s) r.push_back(s);",
            "    }",
            "",
            "    template<class Iter1, class Iter2>",
            "    inline int cmp(Iter1 b1, Iter2 e1, Iter1 b2, Iter2 e2) {",
            "        if (e1 - b1 != e2 - b2) return e1 - b1 < e2 - b2 ? -1 : 1;",
            "        while (e1 != b1) if (*--e1 != *--e2) return *e1<*e2 ? -1 : 1;",
            "        return 0;",
            "    }",
            "}",
            "class biguint {",
            "    std::vector<arith::uint> buf;",
            "public:",
            "    biguint() {}",
            "",
            "    explicit biguint(int x) {",
            "        arith::assert_msg(x >= 0, \"Przypisanie ujemnej liczby\");",
            "        if (x) buf.push_back(x);",
            "    }",
            "",
            "    explicit biguint(unsigned int x) {",
            "        if (x) buf.push_back(x);",
            "    }",
            "",
            "    explicit biguint(long long x) {",
            "        arith::assert_msg(x >= 0, \"Przypisanie ujemnej liczby\");",
            "        if (x) buf.push_back(x);",
            "        if (x >> arith::LOGBASE) buf.push_back(x >> arith::LOGBASE);",
            "    }",
            "",
            "    explicit biguint(unsigned long long x) {",
            "        if (x) buf.push_back(x);",
            "        if (x >> arith::LOGBASE) buf.push_back(x >> arith::LOGBASE);",
            "    }",
            "",
            "    biguint& operator+=(const biguint& y) {",
            "        arith::add(buf, y.buf, buf);",
            "        return *this;",
            "    }",
            "",
            "    biguint& operator-=(const biguint& y) {",
            "        arith::assert_msg(*this >= y, \"Odejmowanie wiekszej liczby\");",
            "        arith::sub(buf, y.buf, buf);",
            "        return *this;",
            "    }",
            "    // Additional operator overloading and member functions omitted for brevity.",
            "}"
        ],
        "description": "This structure defines a `biguint` class for representing arbitrarily large unsigned integers using a custom `arith` namespace for arithmetic operations. The class supports a variety of arithmetic and bitwise operations like addition, subtraction, multiplication, division, bit shifting, and more, along with operator overloading for easy usage in expressions."
    },
    "Euler's Sieve Algorithm": {
        "prefix": "_eulersieve",
        "body": [
            "#define MAXP 1000006",
            "int primes[MAXP], cribas[MAXP], phi[MAXP], _np;",
            "void euler() {",
            "    int i = 2, j;",
            "    for(_np = 0; i < MAXP; i++) {",
            "        if(!cribas[i]) {",
            "            phi[i] = i - 1;",
            "            primes[_np++] = i;",
            "        }",
            "        for(j = 0; j < _np; j++) {",
            "            if(i * primes[j] > MAXP) break;",
            "            cribas[i * primes[j]] = 1;",
            "            if(i % primes[j])",
            "                phi[i * primes[j]] = phi[i] * (primes[j] - 1);",
            "            else {",
            "                phi[i * primes[j]] = phi[i] * primes[j];",
            "                break;",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "This code implements Euler's Sieve algorithm, which computes the Euler's totient function (phi) for all integers from 1 to MAXP using the sieve technique. The function also generates prime numbers up to MAXP. It uses the 'cribas' array to mark multiples of primes and the 'primes' array to store the prime numbers found."
    },
    "Integer to String Conversion Macro": {
        "prefix": "_tostringmacro",
        "body": [
            "char digits[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};",
            "#define _tostring(i){",
            "    int s = 32, r = 10; if ((r) < 2 || (r) > 36 || !(r)) { (r) = 10; }",
            "    SIGN = (i < 0); if (!SIGN) i = -i;",
            "    while (i <= -r) { BUFF[--s] = digits[-(i % r)]; i /= r; } BUFF[--s] = digits[-i];",
            "    if (SIGN) putchar(45); for (i = s; i < 32; putchar(BUFF[i++])); putchar(10);",
            "}"
        ],
        "description": "This macro converts an integer into a string representation in a specified base (between 2 and 36). It handles negative numbers, different base systems, and outputs the string representation using the 'putchar' function. The 'digits' array contains the characters for values in bases larger than 10, from 0-9 and A-Z."
    },
    "Binary Indexed Tree (BIT)": {
        "prefix": "_bitree",
        "body": [
            "int BIT[MAXV];",
            "void update(int i, int n, int v) {",
            "    for (; i <= n; BIT[i] += v, i += (i & -i));",
            "}",
            "int query(int i) {",
            "    int r = 0;",
            "    for (; i; r += BIT[i], i -= (i & -i));",
            "    return r;",
            "}",
            "int query(int a, int b) {",
            "    return (query(b + 1) - query(a));",
            "}"
        ],
        "description": "This code implements a Binary Indexed Tree (BIT) or Fenwick Tree for efficient prefix sum queries and updates. The 'update' function adds a value 'v' to the index 'i' and propagates the update. The 'query' function calculates the prefix sum up to index 'i'. A second 'query' function is defined to return the sum between indices 'a' and 'b' by utilizing the first query function."
    },
    "Aho-Corasick Algorithm": {
        "prefix": "_aho_corasick",
        "body": [
            "#define MAXN 1000011",
            "#define F(x,y) T[x].next[y]",
            "const int alfa = 27;",
            "struct Aho_Corasick {",
            "    struct PMA {",
            "        int suf, next[alfa], accept;",
            "        PMA() {",
            "            accept = -1;",
            "            memset(next, 0, sizeof (next));",
            "            suf = 0;",
            "        }",
            "    };",
            "    int root, size, father[MAXN], Q[MAXN];",
            "    vector<PMA> T;",
            "    int convert(char c) {",
            "        return c - 'a' + 1;",
            "    }",
            "    Aho_Corasick() {",
            "        T.push_back(PMA());",
            "        T.push_back(PMA());",
            "        root = size = 1;",
            "    }",
            "    void add(char *p, int id) {",
            "        int t = root, i = -1;",
            "        while (p[++i]) {",
            "            int c = convert(p[i]);",
            "            if (F(t, c) == 0)",
            "                F(t, c) = ++size, T.push_back(PMA());",
            "            t = F(t, c);",
            "        }",
            "        if (T[t].accept != -1)",
            "            father[id] = T[t].accept;",
            "        else",
            "            T[t].accept = father[id] = id;",
            "    }",
            "    void _buildPMA() {",
            "        T.push_back(PMA());",
            "        int izq = 0, der = 0, c = 0;",
            "        while (++c < alfa)",
            "            if (F(root, c)) {",
            "                F(F(root, c), 0) = root;",
            "                Q[der++] = F(root, c);",
            "            } else",
            "                F(root, c) = root;",
            "        while (izq < der) {",
            "            int t = Q[izq++];",
            "            for (c = 1; c < alfa; ++c)",
            "                if (F(t, c)) {",
            "                    Q[der++] = F(t, c);",
            "                    int r = F(t, 0);",
            "                    while (!F(r, c)) r = F(r, 0);",
            "                    F(F(t, c), 0) = F(r, c);",
            "                    if (T[F(F(t, c), 0)].accept != -1)",
            "                        T[F(t, c)].suf = F(F(t, c), 0);",
            "                    else",
            "                        T[F(t, c)].suf = T[F(F(t, c), 0)].suf;",
            "                }",
            "        }",
            "    }",
            "    void match(char *S, int *cant) {",
            "        int v = root, i = -1;",
            "        while (S[++i]) {",
            "            int c = convert(S[i]);",
            "            while (!F(v, c)) v = F(v, 0);",
            "            v = F(v, c);",
            "            if (T[v].accept != -1)",
            "                cant[T[v].accept]++;",
            "            for (int u = T[v].suf; u; u = T[u].suf)",
            "                if (T[u].accept != -1)",
            "                    cant[T[u].accept]++;",
            "        }",
            "    }",
            "} aho;"
        ],
        "description": "This code implements the Aho-Corasick algorithm, which is used for efficient string matching. The algorithm builds an automaton (PMA) to search for multiple patterns in a text. The main functions include 'add' to insert patterns, '_buildPMA' to construct the automaton, and 'match' to search the text and count occurrences of each pattern. It is particularly useful in applications like keyword matching and dictionary search."
    },
    "Fenwick Tree Structure": {
        "prefix": "_fenwicktree",
        "body": [
            "struct fenwick_tree {",
            "    typedef long long bit_type;",
            "    bit_type* tree;",
            "    bit_type n;",
            "    fenwick_tree():n(MAXV){tree = new bit_type[MAXV];}",
            "    fenwick_tree(int N):n(N){tree = new bit_type[N+1];}",
            "    ~fenwick_tree(){delete tree;}",
            "    void clear(){fill(tree,tree+n+5,0);}",
            "    void update(int i, int val){for (; i <= n;tree[i] += val, i += (i & -i));}",
            "    bit_type query(int i){bit_type sum = 0;for (; i;sum += tree[i], i -= (i & -i));return sum; }",
            "    bit_type query(int a, int b){return (query(b+1) - query(a));}",
            "};"
        ],
        "description": "This structure represents a Fenwick Tree (also known as a Binary Indexed Tree) used for efficient range sum queries and point updates. The tree is implemented using an array, and it supports operations such as updating an element and querying the sum of elements in a range. The 'update' method modifies an element's value, and the 'query' method returns the sum of elements in a given range. This implementation is efficient with time complexity of O(log n) for both update and query operations."
    },
    "Segment Tree Structure": {
        "prefix": "_segmenttree",
        "body": [
            "int A[MAXV], tree[4 * MAXV];",
            "int a, b;",
            "void CREATE(int node,int ini,int fin) {",
            "    if(ini==fin)",
            "        tree[node] = A[ini];",
            "    else {",
            "        CREATE(node*2,ini,(ini + fin)/2);",
            "        CREATE(node*2+1,(ini + fin)/2 + 1,fin);",
            "        tree[node] = min(tree[node*2],tree[node*2 + 1]);",
            "    }",
            "}",
            "void UPDATE(int node,int ini, int fin) {",
            "    if(ini>b||fin<a)",
            "        return;",
            "    if(ini>=a && fin<=b){",
            "        //actualizar aki",
            "        return;",
            "    }",
            "    UPDATE(2*node,ini,(ini+fin)/2);",
            "    UPDATE(2*node+1,(ini+fin)/2+1,fin);",
            "    tree[node] = min(tree[2*node],tree[2*node+1]);",
            "}",
            "int QUERY(int node, int ini, int fin) {",
            "    if(ini>b||fin<a)",
            "        return 1<<19;",
            "    if(ini>=a&&fin<=b)",
            "        return tree[node];",
            "    return min(QUERY(node*2, ini, (ini+fin)/2), QUERY(node*2+1,(ini+fin)/2+1,fin));",
            "}"
        ],
        "description": "This structure implements a Segment Tree for range queries and point updates. The tree is built with the 'CREATE' function, which initializes the tree from the input array. The 'UPDATE' function is used to modify the values in a given range, and the 'QUERY' function is used to retrieve the minimum value in a specified range. This structure efficiently supports range minimum queries and point updates with a time complexity of O(log n)."
    },
    "Suffix Array Structure": {
        "prefix": "_suffixarray",
        "body": [
            "#define MAXSA 200100",
            "// Suffix Array",
            "int _SA[MAXSA], cad[MAXSA], wa[MAXSA], wb[MAXSA], we[MAXSA], wv[MAXSA];",
            "void sufix_array(char *cad, int *_SA, int N, int range = 256) {",
            "    N++;",
            "    int i, j, p, *x = wa, *y = wb;",
            "    memset(we, 0, range * sizeof(int));",
            "    for(i = 0; i < N; i++)",
            "        we[x[i] = cad[i]]++;",
            "    for(i = 1; i < range; i++)",
            "        we[i] += we[i - 1];",
            "    for(i = N - 1; i >= 0; i--)",
            "        _SA[--we[x[i]]] = i;",
            "    for(j = p = 1; p < N; j <<= 1, range = p) {",
            "        for(p = 0, i = N - j; i < N; y[p++] = i, i++);",
            "        for(i = 0; i < N; i++)",
            "            if(_SA[i] >= j) y[p++] = _SA[i] - j;",
            "        for(i = 0; i < N; i++) wv[i] = x[y[i]];",
            "        memset(we, 0, range * sizeof(int));",
            "        for(i = 0; i < N; i++) we[wv[i]]++;",
            "        for(i = 1; i < range; i++) we[i] += we[i - 1];",
            "        for(i = N - 1; i >= 0; i--) _SA[--we[wv[i]]] = y[i];",
            "        swap(x, y);",
            "        x[_SA[0]] = 0;",
            "        for(p = i = 1; i < N; i++)",
            "            x[_SA[i]] = (y[_SA[i]] == y[_SA[i - 1]] && y[_SA[i] + j] == y[_SA[i - 1] + j]) ? p - 1 : p++;",
            "    }",
            "    N--;",
            "}"
        ],
        "description": "This function implements the Suffix Array construction using a modified version of the induced sorting algorithm. The input is a string `cad` of length `N`, and the output is the suffix array `_SA`, which is an array of indices representing the lexicographically sorted suffixes of the string. The algorithm sorts the suffixes using an efficient approach with time complexity of O(N log N). The function uses additional arrays like `wa`, `wb`, `we`, and `wv` to help with the sorting process."
    },
    "Longest Common Prefix": {
        "prefix": "_lcp",
        "body": [
            "// Longest Common Prefix",
            "int rank[MAXV], LCP[MAXV];",
            "void findLCP(int *Num, int *P, int N) {",
            "    int i, j, k = 0;",
            "    for (i = 1; i <= N; i++)",
            "        rank[P[i]] = i;",
            "    for (i = 0; i < N; LCP[rank[i++]] = k)",
            "        for (k ? k-- : 0, j = P[rank[i] - 1]; Num[i + k] == Num[j + k]; k++);",
            "}"
        ],
        "description": "This function computes the Longest Common Prefix (LCP) array for a given suffix array. The LCP array stores the lengths of the longest common prefixes between consecutive suffixes in the suffix array. The `Num` array represents the string (or sequence) and `P` is the suffix array. The algorithm computes the LCP values in O(N) time after the suffix array is built, using a rank array to efficiently compare suffixes."
    },
    "Range Minimum Query": {
        "prefix": "_rmq",
        "body": [
            "#define MAXV 15000",
            "int st[MAXV][20];",
            "// Range Minimum Query < N*logN , 1 >",
            "void RMQ(int n, int *num) {",
            "    int i, j;",
            "    for (i = 0; i < n; st[i][0] = i, i++);",
            "    for (i = 1; (1 << i) <= n; i++)",
            "        for (j = 0; j + (1 << i) <= n; j++)",
            "            st[j][i] = (num[st[j][i-1]] < num[st[j + (1 << (i-1))][i-1]]) ?",
            "                        st[j][i-1] : st[j + (1 << (i-1))][i-1];",
            "}",
            "int query(int a, int b, int *num) {",
            "    int k = log(b - a + 1) / M_LN2;",
            "    return (num[st[a][k]] < num[st[b - (1 << k) + 1][k]]) ? num[st[a][k]] : num[st[b - (1 << k) + 1][k]];",
            "}"
        ],
        "description": "This code implements a Range Minimum Query (RMQ) using sparse tables. The function `RMQ` builds a sparse table for efficient querying of the minimum value in a range. The `query` function finds the minimum value between two indices `a` and `b` using precomputed sparse tables. The time complexity of building the sparse table is O(N*logN), and each query is answered in O(1) time. The sparse table helps speed up range minimum queries by storing results of overlapping subproblems."
    },
    "Knuth-Morris-Pratt Algorithm": {
        "prefix": "_kmp",
        "body": [
            "#define MAXKMP",
            "int pi[MAXKMP]; // prefix function",
            "// Knuth-Morris-Pratt <N + M>",
            "void KMP(char *T, int n, char *P, int m) {",
            "    int i, q, k;",
            "    k = pi[1] = 0;",
            "    for (q = 2; q <= m; pi[q++] = k) {",
            "        while (k && (P[k] != P[q - 1]))",
            "            k = pi[k];",
            "        if (P[k] == P[q - 1])",
            "            k++;",
            "    }",
            "    q = 0;",
            "    for (i = 1; i <= n; i++) {",
            "        while ((q > 0) && (P[q] != T[i - 1]))",
            "            q = pi[q];",
            "        if (P[q] == T[i - 1])",
            "            q++;",
            "        if (q == m) {",
            "            q = pi[q];",
            "        }",
            "    }",
            "}"
        ],
        "description": "This code implements the Knuth-Morris-Pratt (KMP) string matching algorithm. The `KMP` function finds occurrences of the pattern `P` of length `m` within the text `T` of length `n` using a prefix function (`pi`). The time complexity of KMP is O(N + M), where N is the length of the text and M is the length of the pattern. The algorithm first preprocesses the pattern to build the `pi` array, which helps skip unnecessary comparisons during the matching phase."
    },
    "Catalan Numbers and Modular Arithmetic": {
        "prefix": "catalan",
        "body": [
            "typedef long long type;",
            "#define MAXCAT 1010",
            "#define MOD 1000000007",
            "",
            "type egcd(type a,type b,type *x,type *y){",
            "    type u=1LL,v=0LL,q=0LL,r=0LL,m=0LL,n=0LL;",
            "    *x=0LL,*y=1LL;",
            "    while(a) {",
            "        q=(int)floor(b/a);",
            "        r=b%a;",
            "        m=*x-u*q;",
            "        n=*y-v*q;",
            "        b=a; a=r; *x=u; *y=v;",
            "        u=m; v=n;",
            "    }",
            "    return b;",
            "}",
            "",
            "type invMOD(type a,type m){",
            "    type x,y;",
            "    if(egcd(a,m,&x,&y)!=1)",
            "        return 0LL;",
            "    else",
            "        return (x%m)>0?(x%m):(x%m+m);",
            "}",
            "",
            "// Catalan numbers. C_0=1, C_(n+1)=2*(2n+1)*C_n/(n+2)",
            "type _cat[MAXCAT];",
            "void _catalan_numbers(int n) {",
            "    _cat[0]=1LL;",
            "    type tt = 0,i = 0;;",
            "    for(;i<n;i++) {",
            "        tt=((((2*((2*i+1)*(_cat[i]%MOD))%MOD)%MOD)*(invMOD(i+2,MOD)%MOD))%MOD);",
            "        _cat[i+1]=(tt<0)?(tt+MOD):(tt);",
            "    }",
            "}"
        ],
        "description": "This code computes the Catalan numbers using modular arithmetic with a modulus of 10^9+7. The `egcd` function computes the extended greatest common divisor, which is used in the `invMOD` function to compute the modular inverse. The `invMOD` function is used to calculate the modular inverse of numbers, which is crucial for the calculation of Catalan numbers. The `catalan_numbers` function uses a recurrence relation to compute Catalan numbers: C_(n+1) = 2*(2n+1)*C_n/(n+2), and stores the results in the `_cat` array."
    },
    "Pascal's Triangle and Binomial Coefficients": {
        "prefix": "_pascal",
        "body": [
            "#define _P 30",
            "int comb[_P][_P];",
            "void pascal() {",
            "    // comb[n][p] = combinaciÃ³n de n en p",
            "    for(int i = 0,j;i<_P;i++)",
            "        for(j=comb[i][0]=1;j<=i;j++)",
            "            comb[i][j] = comb[i-1][j-1] + comb[i-1][j];",
            "}"
        ],
        "description": "This code computes the binomial coefficients using Pascal's Triangle. The function `pascal` fills the `comb` array, where `comb[n][p]` represents the number of ways to choose `p` elements from a set of `n` elements (n choose p). The coefficients are computed iteratively using the recursive relation: comb[n][p] = comb[n-1][p-1] + comb[n-1][p]."
    },
    "Power Modulo Function": {
        "prefix": "_powmod",
        "body": [
            "int powmod(long long a, int b) {",
            "    long long r=1;",
            "    while(b) {",
            "        if(b%2) r=(r*a)%MOD;",
            "        a=(a*a)%T;",
            "        b/=2;",
            "    }",
            "    return (int)r;",
            "}"
        ],
        "description": "This function calculates (a^b) % MOD using the method of exponentiation by squaring. It iteratively squares the base 'a' and reduces the exponent 'b'. If 'b' is odd, the result is multiplied by 'a' before squaring the base. The result is returned modulo MOD."
    }
}
